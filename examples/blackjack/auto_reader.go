/************************************
 *
 * This file contains auto-generated methods to help certain structs
 * implement boardgame.SubState and boardgame.MutableSubState. It was
 * generated by autoreader.
 *
 * DO NOT EDIT by hand.
 *
 ************************************/

package blackjack

import (
	"errors"
	"github.com/jkomoros/boardgame"
	"github.com/jkomoros/boardgame/enum"
)

// Implementation for MoveShuffleDiscardToDraw

var __MoveShuffleDiscardToDrawReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{}

type __MoveShuffleDiscardToDrawReader struct {
	data *MoveShuffleDiscardToDraw
}

func (m *__MoveShuffleDiscardToDrawReader) Props() map[string]boardgame.PropertyType {
	return __MoveShuffleDiscardToDrawReaderProps
}

func (m *__MoveShuffleDiscardToDrawReader) Prop(name string) (interface{}, error) {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return m.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return m.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return m.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return m.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return m.IntProp(name)
	case boardgame.TypeIntSlice:
		return m.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return m.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return m.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return m.ImmutableStackProp(name)
	case boardgame.TypeString:
		return m.StringProp(name)
	case boardgame.TypeStringSlice:
		return m.StringSliceProp(name)
	case boardgame.TypeTimer:
		return m.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveShuffleDiscardToDrawReader) PropMutable(name string) bool {
	switch name {
	}

	return false
}

func (m *__MoveShuffleDiscardToDrawReader) SetProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return m.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return m.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return m.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return m.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return m.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return m.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return m.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return m.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveShuffleDiscardToDrawReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) BoolProp(name string) (bool, error) {

	return false, errors.New("No such Bool prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetBoolProp(name string, value bool) error {

	return errors.New("No such Bool prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	return errors.New("No such Stack prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	return errors.New("No such ImmutableStack prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) StackProp(name string) (boardgame.Stack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (m *__MoveShuffleDiscardToDrawReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *MoveShuffleDiscardToDraw) Reader() boardgame.PropertyReader {
	return &__MoveShuffleDiscardToDrawReader{m}
}

func (m *MoveShuffleDiscardToDraw) ReadSetter() boardgame.PropertyReadSetter {
	return &__MoveShuffleDiscardToDrawReader{m}
}

func (m *MoveShuffleDiscardToDraw) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__MoveShuffleDiscardToDrawReader{m}
}

// Implementation for MoveFinishTurn

var __MoveFinishTurnReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{}

type __MoveFinishTurnReader struct {
	data *MoveFinishTurn
}

func (m *__MoveFinishTurnReader) Props() map[string]boardgame.PropertyType {
	return __MoveFinishTurnReaderProps
}

func (m *__MoveFinishTurnReader) Prop(name string) (interface{}, error) {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return m.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return m.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return m.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return m.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return m.IntProp(name)
	case boardgame.TypeIntSlice:
		return m.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return m.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return m.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return m.ImmutableStackProp(name)
	case boardgame.TypeString:
		return m.StringProp(name)
	case boardgame.TypeStringSlice:
		return m.StringSliceProp(name)
	case boardgame.TypeTimer:
		return m.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveFinishTurnReader) PropMutable(name string) bool {
	switch name {
	}

	return false
}

func (m *__MoveFinishTurnReader) SetProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveFinishTurnReader) ConfigureProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return m.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return m.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return m.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return m.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return m.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return m.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return m.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return m.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveFinishTurnReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (m *__MoveFinishTurnReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveFinishTurnReader) BoolProp(name string) (bool, error) {

	return false, errors.New("No such Bool prop: " + name)

}

func (m *__MoveFinishTurnReader) SetBoolProp(name string, value bool) error {

	return errors.New("No such Bool prop: " + name)

}

func (m *__MoveFinishTurnReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (m *__MoveFinishTurnReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveFinishTurnReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (m *__MoveFinishTurnReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (m *__MoveFinishTurnReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveFinishTurnReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveFinishTurnReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	return errors.New("No such Stack prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	return errors.New("No such ImmutableStack prop: " + name)

}

func (m *__MoveFinishTurnReader) StackProp(name string) (boardgame.Stack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveFinishTurnReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (m *__MoveFinishTurnReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (m *__MoveFinishTurnReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveFinishTurnReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (m *__MoveFinishTurnReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (m *__MoveFinishTurnReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *MoveFinishTurn) Reader() boardgame.PropertyReader {
	return &__MoveFinishTurnReader{m}
}

func (m *MoveFinishTurn) ReadSetter() boardgame.PropertyReadSetter {
	return &__MoveFinishTurnReader{m}
}

func (m *MoveFinishTurn) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__MoveFinishTurnReader{m}
}

// Implementation for MoveRevealHiddenCard

var __MoveRevealHiddenCardReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{
	"TargetPlayerIndex": boardgame.TypePlayerIndex,
}

type __MoveRevealHiddenCardReader struct {
	data *MoveRevealHiddenCard
}

func (m *__MoveRevealHiddenCardReader) Props() map[string]boardgame.PropertyType {
	return __MoveRevealHiddenCardReaderProps
}

func (m *__MoveRevealHiddenCardReader) Prop(name string) (interface{}, error) {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return m.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return m.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return m.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return m.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return m.IntProp(name)
	case boardgame.TypeIntSlice:
		return m.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return m.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return m.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return m.ImmutableStackProp(name)
	case boardgame.TypeString:
		return m.StringProp(name)
	case boardgame.TypeStringSlice:
		return m.StringSliceProp(name)
	case boardgame.TypeTimer:
		return m.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveRevealHiddenCardReader) PropMutable(name string) bool {
	switch name {
	case "TargetPlayerIndex":
		return true
	}

	return false
}

func (m *__MoveRevealHiddenCardReader) SetProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveRevealHiddenCardReader) ConfigureProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return m.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return m.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return m.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return m.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return m.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return m.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return m.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return m.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveRevealHiddenCardReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) BoolProp(name string) (bool, error) {

	return false, errors.New("No such Bool prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetBoolProp(name string, value bool) error {

	return errors.New("No such Bool prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	switch name {
	case "TargetPlayerIndex":
		return m.data.TargetPlayerIndex, nil

	}

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	switch name {
	case "TargetPlayerIndex":
		m.data.TargetPlayerIndex = value
		return nil

	}

	return errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	return errors.New("No such Stack prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	return errors.New("No such ImmutableStack prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) StackProp(name string) (boardgame.Stack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (m *__MoveRevealHiddenCardReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *MoveRevealHiddenCard) Reader() boardgame.PropertyReader {
	return &__MoveRevealHiddenCardReader{m}
}

func (m *MoveRevealHiddenCard) ReadSetter() boardgame.PropertyReadSetter {
	return &__MoveRevealHiddenCardReader{m}
}

func (m *MoveRevealHiddenCard) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__MoveRevealHiddenCardReader{m}
}

// Implementation for MoveCurrentPlayerHit

var __MoveCurrentPlayerHitReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{
	"TargetPlayerIndex": boardgame.TypePlayerIndex,
}

type __MoveCurrentPlayerHitReader struct {
	data *MoveCurrentPlayerHit
}

func (m *__MoveCurrentPlayerHitReader) Props() map[string]boardgame.PropertyType {
	return __MoveCurrentPlayerHitReaderProps
}

func (m *__MoveCurrentPlayerHitReader) Prop(name string) (interface{}, error) {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return m.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return m.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return m.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return m.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return m.IntProp(name)
	case boardgame.TypeIntSlice:
		return m.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return m.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return m.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return m.ImmutableStackProp(name)
	case boardgame.TypeString:
		return m.StringProp(name)
	case boardgame.TypeStringSlice:
		return m.StringSliceProp(name)
	case boardgame.TypeTimer:
		return m.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerHitReader) PropMutable(name string) bool {
	switch name {
	case "TargetPlayerIndex":
		return true
	}

	return false
}

func (m *__MoveCurrentPlayerHitReader) SetProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerHitReader) ConfigureProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return m.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return m.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return m.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return m.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return m.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return m.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return m.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return m.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerHitReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) BoolProp(name string) (bool, error) {

	return false, errors.New("No such Bool prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetBoolProp(name string, value bool) error {

	return errors.New("No such Bool prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	switch name {
	case "TargetPlayerIndex":
		return m.data.TargetPlayerIndex, nil

	}

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	switch name {
	case "TargetPlayerIndex":
		m.data.TargetPlayerIndex = value
		return nil

	}

	return errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	return errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	return errors.New("No such ImmutableStack prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) StackProp(name string) (boardgame.Stack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (m *__MoveCurrentPlayerHitReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *MoveCurrentPlayerHit) Reader() boardgame.PropertyReader {
	return &__MoveCurrentPlayerHitReader{m}
}

func (m *MoveCurrentPlayerHit) ReadSetter() boardgame.PropertyReadSetter {
	return &__MoveCurrentPlayerHitReader{m}
}

func (m *MoveCurrentPlayerHit) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__MoveCurrentPlayerHitReader{m}
}

// Implementation for MoveCurrentPlayerStand

var __MoveCurrentPlayerStandReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{
	"TargetPlayerIndex": boardgame.TypePlayerIndex,
}

type __MoveCurrentPlayerStandReader struct {
	data *MoveCurrentPlayerStand
}

func (m *__MoveCurrentPlayerStandReader) Props() map[string]boardgame.PropertyType {
	return __MoveCurrentPlayerStandReaderProps
}

func (m *__MoveCurrentPlayerStandReader) Prop(name string) (interface{}, error) {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return m.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return m.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return m.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return m.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return m.IntProp(name)
	case boardgame.TypeIntSlice:
		return m.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return m.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return m.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return m.ImmutableStackProp(name)
	case boardgame.TypeString:
		return m.StringProp(name)
	case boardgame.TypeStringSlice:
		return m.StringSliceProp(name)
	case boardgame.TypeTimer:
		return m.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerStandReader) PropMutable(name string) bool {
	switch name {
	case "TargetPlayerIndex":
		return true
	}

	return false
}

func (m *__MoveCurrentPlayerStandReader) SetProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerStandReader) ConfigureProp(name string, value interface{}) error {
	props := m.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return m.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return m.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return m.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return m.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return m.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return m.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return m.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return m.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return m.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return m.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return m.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return m.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return m.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if m.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return m.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return m.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (m *__MoveCurrentPlayerStandReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) BoolProp(name string) (bool, error) {

	return false, errors.New("No such Bool prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetBoolProp(name string, value bool) error {

	return errors.New("No such Bool prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	switch name {
	case "TargetPlayerIndex":
		return m.data.TargetPlayerIndex, nil

	}

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	switch name {
	case "TargetPlayerIndex":
		m.data.TargetPlayerIndex = value
		return nil

	}

	return errors.New("No such PlayerIndex prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	return errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	return errors.New("No such ImmutableStack prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) StackProp(name string) (boardgame.Stack, error) {

	return nil, errors.New("No such Stack prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (m *__MoveCurrentPlayerStandReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (m *MoveCurrentPlayerStand) Reader() boardgame.PropertyReader {
	return &__MoveCurrentPlayerStandReader{m}
}

func (m *MoveCurrentPlayerStand) ReadSetter() boardgame.PropertyReadSetter {
	return &__MoveCurrentPlayerStandReader{m}
}

func (m *MoveCurrentPlayerStand) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__MoveCurrentPlayerStandReader{m}
}

// Implementation for gameState

var __gameStateReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{
	"CurrentPlayer":   boardgame.TypePlayerIndex,
	"DiscardStack":    boardgame.TypeStack,
	"DrawStack":       boardgame.TypeStack,
	"Phase":           boardgame.TypeEnum,
	"RRHasStarted":    boardgame.TypeBool,
	"RRLastPlayer":    boardgame.TypePlayerIndex,
	"RRRoundCount":    boardgame.TypeInt,
	"RRStarterPlayer": boardgame.TypePlayerIndex,
	"UnusedCards":     boardgame.TypeStack,
}

type __gameStateReader struct {
	data *gameState
}

func (g *__gameStateReader) Props() map[string]boardgame.PropertyType {
	return __gameStateReaderProps
}

func (g *__gameStateReader) Prop(name string) (interface{}, error) {
	props := g.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return g.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return g.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return g.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return g.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return g.IntProp(name)
	case boardgame.TypeIntSlice:
		return g.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return g.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return g.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return g.ImmutableStackProp(name)
	case boardgame.TypeString:
		return g.StringProp(name)
	case boardgame.TypeStringSlice:
		return g.StringSliceProp(name)
	case boardgame.TypeTimer:
		return g.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (g *__gameStateReader) PropMutable(name string) bool {
	switch name {
	case "CurrentPlayer":
		return true
	case "DiscardStack":
		return true
	case "DrawStack":
		return true
	case "Phase":
		return true
	case "RRHasStarted":
		return true
	case "RRLastPlayer":
		return true
	case "RRRoundCount":
		return true
	case "RRStarterPlayer":
		return true
	case "UnusedCards":
		return true
	}

	return false
}

func (g *__gameStateReader) SetProp(name string, value interface{}) error {
	props := g.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (g *__gameStateReader) ConfigureProp(name string, value interface{}) error {
	props := g.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return g.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return g.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return g.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return g.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return g.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return g.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return g.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return g.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return g.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return g.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return g.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return g.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return g.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return g.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return g.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return g.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return g.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return g.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return g.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return g.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return g.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return g.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if g.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return g.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return g.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (g *__gameStateReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (g *__gameStateReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (g *__gameStateReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (g *__gameStateReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (g *__gameStateReader) BoolProp(name string) (bool, error) {

	switch name {
	case "RRHasStarted":
		return g.data.RRHasStarted, nil

	}

	return false, errors.New("No such Bool prop: " + name)

}

func (g *__gameStateReader) SetBoolProp(name string, value bool) error {

	switch name {
	case "RRHasStarted":
		g.data.RRHasStarted = value
		return nil

	}

	return errors.New("No such Bool prop: " + name)

}

func (g *__gameStateReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (g *__gameStateReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (g *__gameStateReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	switch name {
	case "Phase":
		return g.data.Phase, nil

	}

	return nil, errors.New("No such Enum prop: " + name)

}

func (g *__gameStateReader) ConfigureEnumProp(name string, value enum.Val) error {

	switch name {
	case "Phase":
		g.data.Phase = value
		return nil

	}

	return errors.New("No such Enum prop: " + name)

}

func (g *__gameStateReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	switch name {
	case "Phase":
		return boardgame.ErrPropertyImmutable

	}

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (g *__gameStateReader) EnumProp(name string) (enum.Val, error) {

	switch name {
	case "Phase":
		return g.data.Phase, nil

	}

	return nil, errors.New("No such Enum prop: " + name)

}

func (g *__gameStateReader) IntProp(name string) (int, error) {

	switch name {
	case "RRRoundCount":
		return g.data.RRRoundCount, nil

	}

	return 0, errors.New("No such Int prop: " + name)

}

func (g *__gameStateReader) SetIntProp(name string, value int) error {

	switch name {
	case "RRRoundCount":
		g.data.RRRoundCount = value
		return nil

	}

	return errors.New("No such Int prop: " + name)

}

func (g *__gameStateReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (g *__gameStateReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (g *__gameStateReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	switch name {
	case "CurrentPlayer":
		return g.data.CurrentPlayer, nil
	case "RRLastPlayer":
		return g.data.RRLastPlayer, nil
	case "RRStarterPlayer":
		return g.data.RRStarterPlayer, nil

	}

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (g *__gameStateReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	switch name {
	case "CurrentPlayer":
		g.data.CurrentPlayer = value
		return nil
	case "RRLastPlayer":
		g.data.RRLastPlayer = value
		return nil
	case "RRStarterPlayer":
		g.data.RRStarterPlayer = value
		return nil

	}

	return errors.New("No such PlayerIndex prop: " + name)

}

func (g *__gameStateReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (g *__gameStateReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (g *__gameStateReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	switch name {
	case "DiscardStack":
		return g.data.DiscardStack, nil
	case "DrawStack":
		return g.data.DrawStack, nil
	case "UnusedCards":
		return g.data.UnusedCards, nil

	}

	return nil, errors.New("No such Stack prop: " + name)

}

func (g *__gameStateReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	switch name {
	case "DiscardStack":
		g.data.DiscardStack = value
		return nil
	case "DrawStack":
		g.data.DrawStack = value
		return nil
	case "UnusedCards":
		g.data.UnusedCards = value
		return nil

	}

	return errors.New("No such Stack prop: " + name)

}

func (g *__gameStateReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	switch name {
	case "DiscardStack":
		return boardgame.ErrPropertyImmutable
	case "DrawStack":
		return boardgame.ErrPropertyImmutable
	case "UnusedCards":
		return boardgame.ErrPropertyImmutable

	}

	return errors.New("No such ImmutableStack prop: " + name)

}

func (g *__gameStateReader) StackProp(name string) (boardgame.Stack, error) {

	switch name {
	case "DiscardStack":
		return g.data.DiscardStack, nil
	case "DrawStack":
		return g.data.DrawStack, nil
	case "UnusedCards":
		return g.data.UnusedCards, nil

	}

	return nil, errors.New("No such Stack prop: " + name)

}

func (g *__gameStateReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (g *__gameStateReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (g *__gameStateReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (g *__gameStateReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (g *__gameStateReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (g *__gameStateReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (g *__gameStateReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (g *__gameStateReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (g *gameState) Reader() boardgame.PropertyReader {
	return &__gameStateReader{g}
}

func (g *gameState) ReadSetter() boardgame.PropertyReadSetter {
	return &__gameStateReader{g}
}

func (g *gameState) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__gameStateReader{g}
}

// Implementation for playerState

var __playerStateReaderProps map[string]boardgame.PropertyType = map[string]boardgame.PropertyType{
	"Busted":      boardgame.TypeBool,
	"Hand":        boardgame.TypeStack,
	"HiddenHand":  boardgame.TypeStack,
	"Stood":       boardgame.TypeBool,
	"VisibleHand": boardgame.TypeStack,
}

type __playerStateReader struct {
	data *playerState
}

func (p *__playerStateReader) Props() map[string]boardgame.PropertyType {
	return __playerStateReaderProps
}

func (p *__playerStateReader) Prop(name string) (interface{}, error) {
	props := p.Props()
	propType, ok := props[name]

	if !ok {
		return nil, errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return p.ImmutableBoardProp(name)
	case boardgame.TypeBool:
		return p.BoolProp(name)
	case boardgame.TypeBoolSlice:
		return p.BoolSliceProp(name)
	case boardgame.TypeEnum:
		return p.ImmutableEnumProp(name)
	case boardgame.TypeInt:
		return p.IntProp(name)
	case boardgame.TypeIntSlice:
		return p.IntSliceProp(name)
	case boardgame.TypePlayerIndex:
		return p.PlayerIndexProp(name)
	case boardgame.TypePlayerIndexSlice:
		return p.PlayerIndexSliceProp(name)
	case boardgame.TypeStack:
		return p.ImmutableStackProp(name)
	case boardgame.TypeString:
		return p.StringProp(name)
	case boardgame.TypeStringSlice:
		return p.StringSliceProp(name)
	case boardgame.TypeTimer:
		return p.ImmutableTimerProp(name)

	}

	return nil, errors.New("Unexpected property type: " + propType.String())
}

func (p *__playerStateReader) PropMutable(name string) bool {
	switch name {
	case "Busted":
		return true
	case "Hand":
		return false
	case "HiddenHand":
		return true
	case "Stood":
		return true
	case "VisibleHand":
		return true
	}

	return false
}

func (p *__playerStateReader) SetProp(name string, value interface{}) error {
	props := p.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBool:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeBoolSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeEnum:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeInt:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeIntSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndex:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypePlayerIndexSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStack:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeString:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeStringSlice:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")
	case boardgame.TypeTimer:
		return errors.New("SetProp does not allow setting mutable types. Use ConfigureProp instead.")

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (p *__playerStateReader) ConfigureProp(name string, value interface{}) error {
	props := p.Props()
	propType, ok := props[name]

	if !ok {
		return errors.New("No such property with that name: " + name)
	}

	switch propType {
	case boardgame.TypeBoard:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Board)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Board")
			}
			return p.ConfigureBoardProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableBoard)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableBoard")
			}
			return p.ConfigureImmutableBoardProp(name, val)
		}
	case boardgame.TypeBool:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return p.SetBoolProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(bool)
			if !ok {
				return errors.New("Provided value was not of type bool")
			}
			return p.SetBoolProp(name, val)
		}
	case boardgame.TypeBoolSlice:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return p.SetBoolSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]bool)
			if !ok {
				return errors.New("Provided value was not of type []bool")
			}
			return p.SetBoolSliceProp(name, val)
		}
	case boardgame.TypeEnum:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(enum.Val)
			if !ok {
				return errors.New("Provided value was not of type enum.Val")
			}
			return p.ConfigureEnumProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(enum.ImmutableVal)
			if !ok {
				return errors.New("Provided value was not of type enum.ImmutableVal")
			}
			return p.ConfigureImmutableEnumProp(name, val)
		}
	case boardgame.TypeInt:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return p.SetIntProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(int)
			if !ok {
				return errors.New("Provided value was not of type int")
			}
			return p.SetIntProp(name, val)
		}
	case boardgame.TypeIntSlice:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return p.SetIntSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]int)
			if !ok {
				return errors.New("Provided value was not of type []int")
			}
			return p.SetIntSliceProp(name, val)
		}
	case boardgame.TypePlayerIndex:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return p.SetPlayerIndexProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type boardgame.PlayerIndex")
			}
			return p.SetPlayerIndexProp(name, val)
		}
	case boardgame.TypePlayerIndexSlice:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return p.SetPlayerIndexSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]boardgame.PlayerIndex)
			if !ok {
				return errors.New("Provided value was not of type []boardgame.PlayerIndex")
			}
			return p.SetPlayerIndexSliceProp(name, val)
		}
	case boardgame.TypeStack:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Stack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Stack")
			}
			return p.ConfigureStackProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableStack)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableStack")
			}
			return p.ConfigureImmutableStackProp(name, val)
		}
	case boardgame.TypeString:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return p.SetStringProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(string)
			if !ok {
				return errors.New("Provided value was not of type string")
			}
			return p.SetStringProp(name, val)
		}
	case boardgame.TypeStringSlice:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return p.SetStringSliceProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.([]string)
			if !ok {
				return errors.New("Provided value was not of type []string")
			}
			return p.SetStringSliceProp(name, val)
		}
	case boardgame.TypeTimer:
		if p.PropMutable(name) {
			//Mutable variant
			val, ok := value.(boardgame.Timer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.Timer")
			}
			return p.ConfigureTimerProp(name, val)
		} else {
			//Immutable variant
			val, ok := value.(boardgame.ImmutableTimer)
			if !ok {
				return errors.New("Provided value was not of type boardgame.ImmutableTimer")
			}
			return p.ConfigureImmutableTimerProp(name, val)
		}

	}

	return errors.New("Unexpected property type: " + propType.String())
}

func (p *__playerStateReader) ImmutableBoardProp(name string) (boardgame.ImmutableBoard, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (p *__playerStateReader) ConfigureBoardProp(name string, value boardgame.Board) error {

	return errors.New("No such Board prop: " + name)

}

func (p *__playerStateReader) ConfigureImmutableBoardProp(name string, value boardgame.ImmutableBoard) error {

	return errors.New("No such ImmutableBoard prop: " + name)

}

func (p *__playerStateReader) BoardProp(name string) (boardgame.Board, error) {

	return nil, errors.New("No such Board prop: " + name)

}

func (p *__playerStateReader) BoolProp(name string) (bool, error) {

	switch name {
	case "Busted":
		return p.data.Busted, nil
	case "Stood":
		return p.data.Stood, nil

	}

	return false, errors.New("No such Bool prop: " + name)

}

func (p *__playerStateReader) SetBoolProp(name string, value bool) error {

	switch name {
	case "Busted":
		p.data.Busted = value
		return nil
	case "Stood":
		p.data.Stood = value
		return nil

	}

	return errors.New("No such Bool prop: " + name)

}

func (p *__playerStateReader) BoolSliceProp(name string) ([]bool, error) {

	return []bool{}, errors.New("No such BoolSlice prop: " + name)

}

func (p *__playerStateReader) SetBoolSliceProp(name string, value []bool) error {

	return errors.New("No such BoolSlice prop: " + name)

}

func (p *__playerStateReader) ImmutableEnumProp(name string) (enum.ImmutableVal, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (p *__playerStateReader) ConfigureEnumProp(name string, value enum.Val) error {

	return errors.New("No such Enum prop: " + name)

}

func (p *__playerStateReader) ConfigureImmutableEnumProp(name string, value enum.ImmutableVal) error {

	return errors.New("No such ImmutableEnum prop: " + name)

}

func (p *__playerStateReader) EnumProp(name string) (enum.Val, error) {

	return nil, errors.New("No such Enum prop: " + name)

}

func (p *__playerStateReader) IntProp(name string) (int, error) {

	return 0, errors.New("No such Int prop: " + name)

}

func (p *__playerStateReader) SetIntProp(name string, value int) error {

	return errors.New("No such Int prop: " + name)

}

func (p *__playerStateReader) IntSliceProp(name string) ([]int, error) {

	return []int{}, errors.New("No such IntSlice prop: " + name)

}

func (p *__playerStateReader) SetIntSliceProp(name string, value []int) error {

	return errors.New("No such IntSlice prop: " + name)

}

func (p *__playerStateReader) PlayerIndexProp(name string) (boardgame.PlayerIndex, error) {

	return 0, errors.New("No such PlayerIndex prop: " + name)

}

func (p *__playerStateReader) SetPlayerIndexProp(name string, value boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndex prop: " + name)

}

func (p *__playerStateReader) PlayerIndexSliceProp(name string) ([]boardgame.PlayerIndex, error) {

	return []boardgame.PlayerIndex{}, errors.New("No such PlayerIndexSlice prop: " + name)

}

func (p *__playerStateReader) SetPlayerIndexSliceProp(name string, value []boardgame.PlayerIndex) error {

	return errors.New("No such PlayerIndexSlice prop: " + name)

}

func (p *__playerStateReader) ImmutableStackProp(name string) (boardgame.ImmutableStack, error) {

	switch name {
	case "Hand":
		return p.data.Hand, nil
	case "HiddenHand":
		return p.data.HiddenHand, nil
	case "VisibleHand":
		return p.data.VisibleHand, nil

	}

	return nil, errors.New("No such Stack prop: " + name)

}

func (p *__playerStateReader) ConfigureStackProp(name string, value boardgame.Stack) error {

	switch name {
	case "Hand":
		return boardgame.ErrPropertyImmutable
	case "HiddenHand":
		p.data.HiddenHand = value
		return nil
	case "VisibleHand":
		p.data.VisibleHand = value
		return nil

	}

	return errors.New("No such Stack prop: " + name)

}

func (p *__playerStateReader) ConfigureImmutableStackProp(name string, value boardgame.ImmutableStack) error {

	switch name {
	case "Hand":
		slotValue := value.MergedStack()
		if slotValue == nil {
			return errors.New("Hand couldn't be upconverted, returned nil.")
		}
		p.data.Hand = slotValue
		return nil
	case "HiddenHand":
		return boardgame.ErrPropertyImmutable
	case "VisibleHand":
		return boardgame.ErrPropertyImmutable

	}

	return errors.New("No such ImmutableStack prop: " + name)

}

func (p *__playerStateReader) StackProp(name string) (boardgame.Stack, error) {

	switch name {
	case "Hand":
		return nil, boardgame.ErrPropertyImmutable
	case "HiddenHand":
		return p.data.HiddenHand, nil
	case "VisibleHand":
		return p.data.VisibleHand, nil

	}

	return nil, errors.New("No such Stack prop: " + name)

}

func (p *__playerStateReader) StringProp(name string) (string, error) {

	return "", errors.New("No such String prop: " + name)

}

func (p *__playerStateReader) SetStringProp(name string, value string) error {

	return errors.New("No such String prop: " + name)

}

func (p *__playerStateReader) StringSliceProp(name string) ([]string, error) {

	return []string{}, errors.New("No such StringSlice prop: " + name)

}

func (p *__playerStateReader) SetStringSliceProp(name string, value []string) error {

	return errors.New("No such StringSlice prop: " + name)

}

func (p *__playerStateReader) ImmutableTimerProp(name string) (boardgame.ImmutableTimer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (p *__playerStateReader) ConfigureTimerProp(name string, value boardgame.Timer) error {

	return errors.New("No such Timer prop: " + name)

}

func (p *__playerStateReader) ConfigureImmutableTimerProp(name string, value boardgame.ImmutableTimer) error {

	return errors.New("No such ImmutableTimer prop: " + name)

}

func (p *__playerStateReader) TimerProp(name string) (boardgame.Timer, error) {

	return nil, errors.New("No such Timer prop: " + name)

}

func (p *playerState) Reader() boardgame.PropertyReader {
	return &__playerStateReader{p}
}

func (p *playerState) ReadSetter() boardgame.PropertyReadSetter {
	return &__playerStateReader{p}
}

func (p *playerState) ReadSetConfigurer() boardgame.PropertyReadSetConfigurer {
	return &__playerStateReader{p}
}
