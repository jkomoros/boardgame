package movenames

import (
	"bytes"
	"encoding/json"
	"errors"
	"go/format"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/jkomoros/boardgame/boardgame-util/lib/gamepkg"
)

const subFolder = "movenames"

//MoveNameResult is the result of extracting move names for a single game package.
type MoveNameResult struct {
	PackageName string   `json:"packageName"`
	ImportPath  string   `json:"importPath"`
	MoveNames   []string `json:"moveNames"`
}

//Build generates a temporary Go binary that imports all game packages,
//instantiates GameManagers with in-memory storage, and extracts
//non-FixUp move names. It returns the results as a slice of MoveNameResult.
func Build(directory string, pkgs []*gamepkg.Pkg) ([]MoveNameResult, error) {

	if _, err := os.Stat(directory); os.IsNotExist(err) {
		return nil, errors.New("the provided directory, " + directory + " does not exist")
	}

	code, err := Code(pkgs)

	if err != nil {
		return nil, errors.New("couldn't generate code: " + err.Error())
	}

	dir := filepath.Join(directory, subFolder)

	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.Mkdir(dir, 0700); err != nil {
			return nil, errors.New("couldn't create movenames directory: " + err.Error())
		}
	}

	codePath := filepath.Join(dir, "main.go")

	if err := ioutil.WriteFile(codePath, code, 0644); err != nil {
		return nil, errors.New("couldn't save code: " + err.Error())
	}

	cmd := exec.Command("go", "build")
	cmd.Dir = dir

	errBuf := new(bytes.Buffer)
	cmd.Stderr = errBuf

	err = cmd.Run()

	if err != nil {
		return nil, errors.New("couldn't build movenames binary: " + err.Error() + ": " + errBuf.String())
	}

	binaryName := filepath.Join(dir, subFolder)

	if _, err := os.Stat(binaryName); os.IsNotExist(err) {
		return nil, errors.New("sanity check failed: binary does not appear to have been created")
	}

	absBinaryName, err := filepath.Abs(binaryName)
	if err != nil {
		return nil, errors.New("couldn't get absolute path to binary: " + err.Error())
	}

	cmd = exec.Command(absBinaryName)
	cmd.Dir = dir

	outBuf := new(bytes.Buffer)
	errBuf = new(bytes.Buffer)
	cmd.Stdout = outBuf
	cmd.Stderr = errBuf

	err = cmd.Run()

	if err != nil {
		return nil, errors.New("couldn't run movenames binary: " + err.Error() + ": " + errBuf.String())
	}

	var results []MoveNameResult

	if err := json.Unmarshal(outBuf.Bytes(), &results); err != nil {
		return nil, errors.New("couldn't parse movenames output: " + err.Error())
	}

	return results, nil
}

//Code returns the source code for a temporary Go binary that extracts move
//names from the given game packages.
func Code(pkgs []*gamepkg.Pkg) ([]byte, error) {

	buf := new(bytes.Buffer)

	err := codeTemplate.Execute(buf, map[string]interface{}{
		"pkgs": pkgs,
	})

	if err != nil {
		return nil, errors.New("couldn't execute code template: " + err.Error())
	}

	formatted, err := format.Source(buf.Bytes())

	if err != nil {
		return nil, errors.New("couldn't format code output: " + err.Error())
	}

	return formatted, nil
}

//Clean removes the movenames/ directory that was generated within directory
//by Build.
func Clean(directory string) error {
	return os.RemoveAll(filepath.Join(directory, subFolder))
}

var codeTemplate = template.Must(template.New("movenames").Parse(codeTemplateText))

var codeTemplateText = `/*

A temporary binary generated by boardgame-util to extract move names from game packages.

*/
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/jkomoros/boardgame"
	"github.com/jkomoros/boardgame/base"
	memorystorage "github.com/jkomoros/boardgame/storage/memory"
	{{- range .pkgs}}
	"{{.Import}}"
	{{- end}}
)

type delegateEntry struct {
	delegate   boardgame.GameDelegate
	importPath string
}

type moveNameResult struct {
	PackageName string   ` + "`" + `json:"packageName"` + "`" + `
	ImportPath  string   ` + "`" + `json:"importPath"` + "`" + `
	MoveNames   []string ` + "`" + `json:"moveNames"` + "`" + `
}

func main() {
	entries := []delegateEntry{
		{{- range .pkgs}}
		{delegate: {{.Name}}.NewDelegate(), importPath: "{{.Import}}"},
		{{- end}}
	}

	var results []moveNameResult

	for _, entry := range entries {
		storage := memorystorage.NewStorageManager()
		manager, err := boardgame.NewGameManager(entry.delegate, storage)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: couldn't create manager for %s: %v\n", entry.delegate.Name(), err)
			continue
		}

		var names []string
		for _, move := range manager.ExampleMoves() {
			if base.IsFixUp(move) {
				continue
			}
			names = append(names, move.Info().Name())
		}

		results = append(results, moveNameResult{
			PackageName: entry.delegate.Name(),
			ImportPath:  entry.importPath,
			MoveNames:   names,
		})
	}

	encoder := json.NewEncoder(os.Stdout)
	if err := encoder.Encode(results); err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding results: %v\n", err)
		os.Exit(1)
	}
}
`
